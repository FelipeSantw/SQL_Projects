/*CONSTRAINTS*/

CREATE DATABASE BD_CONSTRAINTS

USE BD_CONSTRAINTS

/*IDENTITY*/

CREATE TABLE tb_identity(
Cod INT IDENTITY PRIMARY KEY,
NOME VARCHAR(50)
)

INSERT INTO tb_identity (NOME)
VALUES ('LINHA 1'), ('LINHA 2')

-- APRESENTAR ERRO

INSERT INTO tb_identity (Cod, NOME)
VALUES (3, 'LINHA 3')


SELECT * FROM tb_identity

/*PK*/

CREATE TABLE tb_pk(
Cod INT CONSTRAINT pk_test PRIMARY KEY,
NOME VARCHAR(50)
)

INSERT INTO tb_pk(Cod, NOME)
VALUES(1,'LINHA 1'), (2, 'LINHA 3')

-- APRESENTAR ERRO
INSERT INTO tb_pk (Cod, NOME)
VALUES(2, 'LINHA 4')

SELECT * FROM tb_pk

/*FK*/

CREATE TABLE tb_fk_carro(
Placa varchar(6) PRIMARY KEY,
modelo VARCHAR(50),
fk_marca INT FOREIGN KEY REFERENCES tb_fk_marca(Cod)
)

INSERT INTO tb_fk_marca(NOME)
VALUES ('VW'), ('CHEVROLET'), ('TOYOTA')

INSERT INTO tb_fk_carro (Placa,modelo,fk_marca)
VALUES('PLA001', 'FOX', 1),
		('PLA002', 'ONIX SEDAN', 2)

--APRESENTAR ERRO

INSERT INTO tb_fk_carro(Placa,modelo,fk_marca)
VALUES('PLA004','ARGO',4)

SELECT * FROM tb_fk_marca
SELECT * FROM tb_fk_carro


/*UNIQUE*/

CREATE TABLE tb_unique(
Cod INT PRIMARY KEY IDENTITY,
Nome VARCHAR(50),
CPF CHAR(11) CONSTRAINT UQ_CPF UNIQUE
)

INSERT INTO tb_unique (NOME, CPF)
VALUES('PESSOA A', '11122233344'), ('PESSOA B', '11122233345')

-- APRESENTAR ERRO

INSERT INTO tb_unique (NOME, CPF)
VALUES('PESSOA C', '11122233344')

SELECT * FROM tb_unique

/*NOT NULL*/

CREATE TABLE tb_notnull(
Cod INT PRIMARY KEY IDENTITY
NOME VARCHAR(50) NOT NULL,
DT DATE NULL
)

INSERT INTO tb_notnull(NOME, DT)
VALUES('A', GETDATE())

--APRESENTAR ERRO
INSERT INTO tb_notnull (NOME, DT)
VALUES(NULL, GETDATE())

SELECT * FROM tb_notnull

/*DEFAULT*/

CREATE TABLE tb_default(
Cod INT PRIMARY KEY IDENTITY,
Nome VARCHAR(50),
dtInsert DATE CONSTRAINT DF_DATA DEFAULT (GETDATE())
)

INSERT INTO tb_default(Nome, dtInsert)
VALUES('A', '2020-04-15')

--VERIFICAR VALOR DE DEFAULT

INSERT INTO tb_default(nome)
VALUES('8')

SELECT * FROM tb_default

/*CHECK*/

CREATE TABLE tb_check(
Cod INT PRIMARY KEY IDENTITY,
NOME VARCHAR(50) NOT NULL,
VALOR NUMERIC(6,2) CHECK(VALOR > 0),
LETRA CHAR(1) CHECK (LETRA IN('A','B','C'))
)

INSERT INTO tb_check(NOME, VALOR, LETRA)
VALUES ('linha 1', 100.99, 'A')

-- APRESENTAR ERRO 1:CAMPO VALOR
INSERT INTO tb_check (NOME, VALOR, LETRA)
VALUES('LINHA 2', 0,'A')

-- APRESENTAR ERRO 2: CAMPO LETRA
INSERT IN TO tb_check (NOME, VALORE, LETRA)
VALUES('LINHA 2', 20, 'D')

SELECT * FROM tb_check

-- FIM 1° SCRIPT --

/*DESENVOLVENDO CONSULTAS SQL*/

CREATE DATABASE BD_CONSULTAS;

USE BD_CONSULTAS

CREATE TABLE TB_FUNC(
	MATRICULA INT PRIMARY KEY IDENTITY,
	NOME VARCHAR(255) NOT NULL,
	DATA_NASC DATE NOT NULL,
	SALARIO MONEY NULL,
	DATA_ADMISSAO DATE DEFAULT(GETDATE()),
	DATA_DEMISSAO DATE NULL,
	INICIO_FERIAS DATE NULL,
	FIM_FERIAS DATE NULL,
	STATUS_FUNC VARCHAR(20) CHECK (STATUS_FUNC IN ('ATIVO', 'INATIVO', 'FERIAS', 'LICENÇA', 'INSS')),
	COD_DEPTO INT
	)
	
	
INSERT INTO TB_FUNC(NOME, DATA_NASC, SALARIO, DATA_ADMISSAO, DATA_DEMISSAO, INICIO_FERIAS, FIM_FERIAS, STATUS_FUNC, COD_DEPTO)
	VALUES
		('ANA MARIA', '2000-01-01', 1200.55, '2018-05-01',NULL,NULL,NULL,'ATIVO',1),
		('JOSE HENRIQUE', '1998-11-20', 2575.55, '2005-09-01','2017-12-01',NULL,NULL,'INATIVO',7),
		('ANA MARIA', '2002-08-21', 950.00, '2019-01-01',NULL,NULL,NULL,'ATIVO',6),
		('LUAN FELIX', '1991-09-28', 3500.00, '2013-04-01',NULL,NULL,NULL,'ATIVO',1),
		('FELIPE JOSE DOS SANTOS', '1996-01-11', 4000, '2011-05-01','2015-01-29',NULL,NULL,'INATIVO',2),
		('MARCELO JOSE', '1980-10-05', 7000, '2000-05-01',NULL,'2019-05-01','2019-06-01','ATIVO',2),
		('MARIANA MARIA', '1987-02-08', 4500, '2010-01-01',NULL,NULL,NULL,'INSS',3),
		('JULIANA MARIA DOS SANTOS', '2002-01-01', 2000, '2017-05-01',NULL,NULL,NULL,'LICENÇA',5),
		('MARIA ALICIA', '2001-01-01', 950, '2018-05-01',NULL,NULL,NULL,'ATIVO',4)
	
	
INSERT INTO TB_FUNC (NOME, DATA_NASC, SALARIO, STATUS_FUNC, COD_DEPTO)
	VALUES
		('MARIA ALICIA', '2003-09-18', 950, 'ATIVO', 3)
		
		
/*ORDER BY*/

-- asc
SELECT *
	FROM TB_FUNC
	ORDER BY NOME
	
-- por 2 colunas asc
SELECT *
	FROM TB_FUNC
	ORDER BY NOME, SALARIO
	
-- desc
SELECT *
	FROM TB_FUNC
	ORDER BY NOME DESC
	
-- por 2 colunas, 1 asc, 1 desc
SELECT *
	FROM TB_FUNC
	ORDER BY NOME ASC, SALARIO DESC
	
/*OPERADORES LÓGICOS: AND | OR | NOT */

-- AND
SELECT MATRICULA, NOME, DATA_DEMISSAO, STATUS_FUNC
	FROM TB_FUNC
		WHERE DATA_DEMISSAO IS NULL
		AND STATUS_FUNC = 'ATIVO'
		
-- OR
SELECT MATRICULA, NOME, DATA_DEMISSAO, STATUS_FUNC
	FROM TB_FUNC
		WHERE DATA_DEMISSAO IS NULL
		OR STATUS_FUNC = 'ATIVO'
		
-- NOT
SELECT MATRICULA, NOME, SALARIO, STATUS_FUNC
	FROM TB_FUNC
	WHERE NOT STATUS_FUNC = 'ATIVO'
	
/*OPERADORES ARITMÉTICOS*/

SELECT 
	NOME,
	SALARIO + 50 AS ADICAO,
	SALARIO - 20 AS SUBTRACAO,
	SALARIO * 1.20 AS AJUSTE_20_PCENTO,
	SALARIO / 2 AS DIVISAO,
	FROM TB_FUNC
	WHERE STATUS_FUNC = 'ATIVO'
	
/*OPERADORES RELACIONAIS*/

SELECT *
	FROM TB_FUNC
		WHERE STATUS_FUNC = 'ATIVO'

SELECT *
	FROM TB_FUNC
		WHERE DAT_NASC >= '1999-01-01'

SELECT *
	FROM TB_FUNC
		WHERE SALARIO >= 2000
		AND SALARIO <= 4000

SELECT *
	FROM TB_FUNC
		WHERE STATUS_FUNC <> 'ATIVO'
		
/*OPERADORES AUXILIARES*/

-- IS NULL
SELECT *
	FROM TB_FUNC
		WHERE DATA_DEMISSAO IS NULL
		
-- IS NOT NULL
SELECT *
	FROM TB_FUNC
		WHERE DATA_DEMISSAO IN NOT NULL
		
-- BETWEEN
SELECT *
	FROM TB_FUNC
		WHERE DATA_ADMISSAO BETWEEN '2012-01-01' AND '2018-12-20'
		
SELECT *
	FROM TB_FUNC
		WHERE DATA_ADMISSAO NOT BETWEEN '2017-01-01' AND '2017-12-20'
		
SELECT *
	FROM TB_FUNC
		WHERE COD_DEPTO BETWEEN 5 AND 15
		
-- IN
SELECT *
	FROM TB_FUNC
		WHERE STATUS_FUNC IN ('ATIVO', 'FERIAS')
		
SELECT *
	FROM TB_FUNC
		WHERE MONTH(DATA_ADMISSAO) IN (1,2)
		
SELECT *
	FROM TB_FUNC
		WHERE MONTH(DATA_ADMISSAO) NOT IN (10,11)
		
-- LIKE
SELECT *
	FROM TB_FUNC
		WHERE NOME LIKE 'JOSE'
		
SELECT *
	FROM TB_FUNC
		WHERE NOME LIKE 'JOSE%'
		
SELECT *
	FROM TB_FUNC
		WHERE NOME LIKE '%JOSE'
		
SELECT *
	FROM TB_FUNC
		WHERE NOME LIKE '%JOSE%'
		
/*CLAUSULAS EXTRAS*/

-- ALIAS
SELECT
	F.NOME AS 'NOME FUNCIONÁRIO', 
	'DATA DE ADMISSÃO' = F.DATA_ADMISSAO,
	F.SALARIO 'SALÁRIO FUNCIONÁRIO'
	FROM TB_FUNC AS F

-- CASE
SELECT NOME, STATUS_FUNC,
	CASE STATUS_FUNC
		WHEN 'ATIVO' THEN 'A'
		WHEN 'INATIVO' THEN 'I'
		WHEN 'FERIAS' THEN 'F'
	ELSE 
		'O'
	END SIGLA_STATUS
	FROM TB_FUNC
	
SELECT NOME, SALARIO,
	CASE 
		WHEN SALARIO > 1200 AND SALARIO < 1500 THEN SALARIO * 1.1
		WHEN SALARIO > 1501 AND SALARIO < 2000 THEN SALARIO * 1.2
		WHEN SALARIO < 1000 THEN SALARIO
	END SALARIO_COM_REAJUSTE
	
	FROM TB_FUNC
	
-- DISTINCT
SELECT DISTINCT NOME
	FROM TB_FUNC
	
SELECT DISTINCT NOME, SALARIO
	FROM TB_FUNC 
	
SELECT DISTINCT NOME, SALARIO, DATA_NASC
	FROM TB_FUNC 
	
-- TOP
SELECT
	TOP 5 MATRICULA,
		NOME
	FROM TB_FUNC
	
SELECT 
	TOP 5 MATRICULA, NOME
	FROM TB_FUNC
	ORDER BY MATRICULA DESC

--FIM 2° SCRIPT--

/*JOINS*/ -- PERSONALIZADO COM NOMEAMENTO DE CONSTRAINTS
CREATE DATABASE BD_JOINS
GO

USE BD_JOINS
GO

CREATE TABLE DEPARTAMENTO(
	CODIGO INT CONSTRAINT PK_CODIGO_DEP PRIMARY KEY IDENTITY,
	DESCRICAO VARCHAR(100) NOT NULL);
GO

CREATE TABLE FUNCAO (
	CODIGO INT CONSTRAINT PK_CODIGO_FUNCAO PRIMARY KEY IDENTITY,
	DESCRICAO VARCHAR(100) NOT NULL
	)
GO

CREATE TABLE FUNCIONARIO(
	MATRICULA INT CONSTRAINT PK_MATRICULA_FUNC PRIMARY KEY IDENTITY,
	NOME VARCHAR(255) NOT NULL,
	DATANASCIMENTO DATE NOT NULL,
	CPF CHAR(11) CONSTRAINT UQ_CPF UNIQUE CONSTRAINT CHK_CPF CHECK (LEN(CPF) = 11) NOT NULL,
	SALARIO MONEY NULL,
	DATAADMISSAO DATE CONSTRAINT DEF_DTADM DEFAULT (GETDATE()),
	DATADEMISSAO DATE NULL,
	INICIOFERIAS DATE NULL,
	FIMFERIAS DATE NULL,
	STATUS_FUNC VARCHAR(20) CONSTRAINT CHK_STATUS_FUNC CHECK(STATUS_FUNC IN ('ATIVO', 'INATIVO', 'FERIAS', 'LICENÇA', 'INSS')),
	COD_DEPTO INT CONSTRAINT FK_COD_DEPTO FOREIGN KEY REFERENCES DEPARTAMENTO (CODIGO),
	COD_SUPERVISOR INT CONSTRAINT FK_COD_SUPERVISOR FOREIGN KEY REFERENCES FUNCIONARIO (MATRICULA),
	COD_FUNCAO INT CONSTRAINT FK_COD_FUNCAO FOREIGN KEY REFERENCES FUNCAO(CODIGO)
	)
GO

INSERT INTO DEPARTAMENTO
	VALUES  ('TECNOLOGIA DA INFORMAÇÃO'),
			('RECURSOS HUMANOS'),
			('JURIDICO'),
			('SELEÇÃO'),
			('CONTABILIDADE'),
			('CONTAS A PAGAR E RECEBER'),
			('DEPARTAMENTO PESSOAL')
GO

INSERT INTO FUNCAO
	VALUES ('ESTAGIÁRIO'), ('ANALISTA JR'), ('ANALISTA PL'), ('ANALISTA SR'), ('COORDENADOR'), ('GERENTE')
GO

INSERT INTO FUNCIONARIO (NOME, DATANASCIMENTO, CPF, SALARIO, DATAADMISSAO, DATADEMISSAO, INICIOFERIAS, FIMFERIAS, 
		STATUS_FUNC, COD_DEPTO, COD_SUPERVISOR, COD_FUNCAO)
		VALUES
			('ANA MARIA', '2000-01-01', '12345678911', 1200.55, '2018-05-01',NULL,NULL,NULL,'ATIVO',1,6,2),
			('ANA MARIA', '2002-08-21','12345678913', 950.00, '2019-01-01',NULL,NULL,NULL, 'ATIVO', 6, NULL, 1),
			('LUAN FELIX', '1991-09-28','12345678914', 3500.00, '2013-04-01',NULL,NULL,NULL, 'ATIVO', 3,NULL,2),
			('FELIPE JOSE DOS SANTOS', '1996-01-11','12345678915', 4000, '2011-05-01','2015-01-29',NULL,NULL, 'INATIVO', 2, NULL, 3),
			('MARCELO JOSE', '1980-10-05','12345678916', 7000, '2000-05-01',NULL,'2019-05-01','2019-06-01', 'ATIVO', 1, NULL, 1),
			('MARIANA MARIA', '1987-02-08','12345678917', 4500, '2010-01-01',NULL,NULL,NULL, 'INSS', 1, 6, 3 ),
			('JULIANA MARIA DOS SANTOS', '2002-01-01','12345678918', 2000, '2017-05-01',NULL,NULL,NULL, 'LICENÇA', 5, NULL, 2 ),
			('MARIA ALICIA', '2001-01-01','12345678919', 950, '2018-05-01',NULL,NULL,NULL, 'ATIVO', 1, 6, 1)
GO			

INSERT INTO FUNCIONARIO (NOME, DATANASCIMENTO, CPF, SALARIO, 
		STATUS_FUNC, COD_DEPTO, COD_SUPERVISOR, COD_FUNCAO)
		VALUES ('MARIA ALICIA', '2003-09-18', '12345678920', 950, 'ATIVO',NULL,NULL,1)

SELECT *
	FROM DEPARTAMENTO
SELECT *
	FROM FUNCAO
SELECT *
	FROM FUNCIONARIO

--INNER JOIN

SELECT 
	F.MATRICULA, F.NOME, F.SALARIO,

	D.DESCRICAO as 'DEPARTAMENTO',

	FUN.DESCRICAO as 'FUNÇÃO'

	FROM FUNCIONARIO as F

			INNER JOIN DEPARTAMENTO as D
				ON F.COD_DEPTO = D.CODIGO

			INNER JOIN FUNCAO as FUN
				ON F.COD_FUNCAO = FUN.CODIGO

-- LEFT JOIN
SELECT 
	F.NOME,
	D.DESCRICAO,
	D.CODIGO

FROM FUNCIONARIO as F -- Tabela esquerda
	LEFT JOIN DEPARTAMENTO as D -- Tabela Direita
		ON F.COD_DEPTO = D.CODIGO

WHERE D.CODIGO IS NULL

-- RIGHT JOIN
SELECT 
	F.NOME,
	F.SALARIO,
	D.DESCRICAO,
	D.CODIGO
FROM FUNCIONARIO AS F
	RIGHT JOIN DEPARTAMENTO AS D
		ON F.COD_DEPTO = D.CODIGO
				
WHERE F.COD_DEPTO IS NULL

-- FULL JOIN
SELECT 
	F.NOME,
	D.DESCRICAO
FROM FUNCIONARIO AS F
	FULL JOIN DEPARTAMENTO AS D
		ON F.COD_DEPTO = D.CODIGO
				
WHERE F.COD_DEPTO IS NULL
	OR D.CODIGO IS NULL
	
-- CROSS JOIN - PEGA TODOS DE UMA TABELA E CORRELACIONA COM TODOS DE OUTRA TABELA
SELECT
	F.NOME,
	D.DESCRICAO
FROM FUNCIONARIO AS F
	CROSS JOIN DEPARTAMENTO AS D

SELECT
	F.NOME,
	FUN.DESCRICAO
FROM FUNCIONARIO AS F
	CROSS JOIN FUNCAO AS FUN
	
SELECT
	F.NOME,
	D.DESCRICAO,
	FUN.DESCRICAO
FROM FUNCIONARIO AS F
	CROSS JOIN DEPARTAMENTO AS D
	CROSS JOIN FUNCAO AS FUN

-- SELF JOIN
SELECT
	F.NOME as FUNCIONARIO, -- UTILIZADO 'AS' PARA NÃO FICAR DUAS COLUNAS COM 'NOME' 'NOME' 
	S.NOME as SUPERVISOR -- ESPECIFICANDO QUAL É QUAL.
FROM FUNCIONARIO F
	INNER JOIN FUNCIONARIO S
		ON F.COD_SUPERVISOR = S.MATRICULA

SELECT
	F.NOME AS FUNCIONARIO,
	S.NOME AS SUPERVISOR
FROM FUNCIONARIO F
	LEFT JOIN FUNCIONARIO S
		ON F.COD_SUPERVISOR = S.MATRICULA
				
SELECT
	F.NOME AS FUNCIONARIO,
	S.NOME AS SUPERVISOR
FROM FUNCIONARIO F
	RIGHT JOIN FUNCIONARIO S
		ON F.COD_SUPERVISOR = S.MATRICULA	

SELECT
	F.NOME AS FUNCIONARIO,
	S.NOME AS SUPERVISOR
FROM FUNCIONARIO F
	FULL JOIN FUNCIONARIO S
		ON F.COD_SUPERVISOR = S.MATRICULA
		
SELECT
	F.NOME AS FUNCIONARIO,
	S.NOME AS SUPERVISOR
FROM FUNCIONARIO F
	CROSS JOIN FUNCIONARIO S
		

--FIM 3° SCRIPT--

/*UNIÃO DE CONSULTAS*/

CREATE DATABASE BD_UNIAO_CONSULTAS
GO
USE BD_UNIAO_CONSULTAS
GO
CREATE TABLE A(
	ID INT NOT NULL,
	NOME VARCHAR(10) NOT NULL)

CREATE TABLE B(
	ID INT NOT NULL,
	NOME VARCHAR(10) NOT NULL)
	
INSERT INTO A VALUES (1, 'José'), (2, 'Maria'), (3, 'João')
INSERT INTO B VALUES (2, 'Maria'), (3, 'Guilherme'), (4, 'Vitória')

-- UNION
SELECT ID as 'id pessoa', NOME as 'Nome pessoa' FROM A
UNION
SELECT ID, NOME FROM B
ORDER BY NOME 

-- UNION ALL
SELECT ID, NOME FROM A
UNION ALL
SELECT ID, NOME FROM B

-- EXCEPT
SELECT ID, NOME FROM A
EXCEPT
SELECT ID, NOME FROM B

-- INTERSECT
SELECT ID, NOME FROM A
INTERSECT
SELECT ID, NOME FROM B

--FIM 4° SCRIPT--

/*FUNÇÕES*/

--- Conversão ---

/*DATAS DO SISTEMA*/

SELECT GETDATE() as TEST_GETDATE
SELECT CURRENT_TIMESTAMP AS TESTE_CURRENT
SELECT SYSDATETIME() AS TEST_SYSUTCDATETIME

/*CONVERSÃO CAST*/

DECLARE @DT DATETIME
SET @DT = GETDATE()

SELECT CAST (@DT  AS DATE) TEST_CAST
SELECT TRY_CAST (@DT AS TINYINT) TESTE_TRYCAST

/*CONVERSÃO CONVERT*/

DECLARE @DT DATETIME
SET @DT = GETDATE()

SELECT CONVERT(DATE, @DT) TEST_CONVERT
SELECT CONVERT(VARCHAR, @DT, 103) TEST_CONVERT_DT
SELECT TRY_CONVERT (TINYINT, @DT) TESTE_TRYCONVERT 

/************TEXTO***************/

/* SUBTRING */

DECLARE @TXT VARCHAR(10) = 'ABCDE'
SELECT SUBSTRING (@TEXTM, 1, 3) AS TEST_SUBSTRING

/*LEFT E RIGHT*/

DECLARE @TEXT VARCHAR(10) = 'ABCDE'

	SELECT LEFT (@TXT, 2) TEST_LEFT
	SELECT LEFT (@TXT, 2) TEST_RIGHT
	
/*LEN*/

DECLARE @TXT VARCHAR(10) = 'ABCDE'

SELECT LEN (@TXT) AS TEST_LEN

/*CHARINDEX*/

DECLARE @TXT VARCHAR(20) = 'CONSULTA BD'
SELECT CHARINDEX ('', @TXT) TESTE_CHARINDEX

/*PATINDEX*/

DECLARE @TXT VARCHAR(50)
SET @TXT = 'CONSULTA BD, ONDE ESTUDAMOS SOBRE OS BDS E LINGUAGEM SQL.'

SELECT PATINDEX('%BD%', @TXT) as TEST_PATINDEX

/*REPLACE*/

DECLARE @TXT VARCHAR(50)
SET @TXT = 'APELIDO : PADAWAN'

SELECT REPLACE (@TXT, ':', '>>>') TEST_REPLACE

/*UPPER E LOWER*/

DECLARE @TXT VARCHAR(10) = 't-SQL'

SELECT UPPER(@TXT) TEST_UPPER
SELECT LOWER(@TXT) TEST_LOWER

/*RTRIM, LTRIM, TRIM*/

DECLARE @TXT VARCHAR(20) = '   T-SQL   '

SELECT RTRIM(@TXT) TEST_RTRIM
SELECT LTRIM(@TXT) TEST_LTRIM
SELECT RTRIM(LTRIM(@TXT)) TEST_RTRIM_LTRIM
SELECT TRIM(@TXT) TEST_TRIN 

/*CONCATENANDO TEXTOS*/

DECLARE @TXT VARCHAR(20) = 'SQL SERVER'

-->>ERRO<<

SELECT @TXT + ' ' + CONVERT (VARCHAR(4), 2017) TEST_PLUS_CONVERT

-->Modo de concatenação em concant
SELECT CONCAT (@TXTM, '', 2017) TEST_CONCAT.

/****************DATA**********************/

/*DATE PART*/

SELECT 
DATEPART(YEAR, GETDATE*())AS 'ANO',
DATEPART(QUARTER, GETDATE()) AS 'QUARTO DO ANO'
DATEPART(MONTH, GETDATE()) AS 'MES';
DATEPART (DAYOFYEAR, GETNAME()) AS 'DIA DO ANO (DE 1 A 365)';
DATEPART (DAY, GETDATE ()) AS 'DIA';
DATEPART (WEEK, GETDATE()) AS 'SEMANA';
DATEPART (WEEKDAY, GETDATE()) AS 'DIA DA SEMANA';
DATEPART (HOUR, GATEDATE()) AS 'HORA';
DATEPART (MINUTE, GETDATE()) AS 'MINUTO';
DATEPART (SECOND, GETDATE()) AS 'SEGUNDO';
DATEPART (MILLISECOND, GETDATE()) AS 'MILISSEGUNDO'
DATEPART (MICROSECOND, GETDATE()) AS 'MICROSEGUNDO'
DATEPART (NANOSECOND, GETDATE() AS 'Nanosegundo'



/*DATEDIFF*/

SELECT 
DATEDIFF(YEAR, '2018-01-01', GETDATE()) AS 'ANO',
DATEDIFF(MONTH, '2018-01-01', GETDATE()) AS 'MÊS',
DATEDIFF(DAY, '2018-01-01', GETDATE ()) AS 'DIAS'
DATEDIFF(WEEK, '2018-01-01', GETDATE()) AS 'SEMANA',
DATEDIFF (HOUR, '2018-01.01', GETDATE()) AS 'HORA',
DATEDIFF (MINUTE, '2018-01-01', GETDATE()) AS 'MINUTO'


/*DATEADO*/

SELECT
	DATEADD(YEAR, 5, GETDATE()) AS 'ANO ADICIONADO',
	DATEADD(YEAR, -5, GETDATE()) AS 'ANO SUBTRAIDO',
	DATEADD(MONTH, 5, GETDATE()) AS 'MÊS',
	DATEADD(DAY, 5, GETDATE()) AS 'DIA',
	DATEADD(WEEK, 5, GETDATE()) AS 'SEMANA',
	DATEADD(HOUR, 5, GETDATE()) AS 'HORA'.
	
/*DATENAME*/

SELECT
	DATENAME(YEAR, GETDATE()) AS 'ANO',
	DATENAME(MONTH, GETDATE()) AS 'MES',
	DATENAME(WEEKDAY, GETDATE()) AS 'DIA DA SEMANA'.
	
/*YEAR, MONTH, DAY, EOMONTH*/

SELECT
GETDATE() DATA_SISTEMA,
YEAR(GETDATE()) AS 'ANO',
MONTH(GETDATE()) AS 'MÊS',
DAY(GETDATE()) AS 'DIA',
EOMONTH(GETDATE()) AS 'ULTIMO DIA DO MES'

/*ISDATE*/

SELECT ISDATE(GETDATE()) AS TEST_DATE_VALID

SELECT ISDATE('2018-13-01') AS TEST_DATE_INVALID

/*TRATAMENTO DE NULOS*/

SELECT
ISNULL(NULL, 'SQL') AS TEST_ISNULL,
NULLIF('SQL', 'SQL') AS TEST_NULLIFM
NULLIF('T-SQL','SQL') AS TEST_NULLIF2
COALESCE(NULL, NULL, 'SQL') AS TEST_COALESCE
COALESCE(NULL, 'T-SQL', 'SQL') AS TEST_COALESCE2

------------------------------------------------------
/*TRATAMENTO DE TEXTO*/

/*SUBSTRING*/

DECLARE @TXT VARCHAR(10) = 'ABCDE'
SELECT SUBSTRING(@TXT,1,3) AS TEST_SUBSTRING

/*LEFT E RIGHT*/

DECLARE @TXT VARCHAR(10) = 'ABCDE'

SELECT LEFT(@TXT, 2) TEST_LEFT
SELECT RIGHT(@TXT,2) TEST_RIGHT

/*LEN*/

DECLARE @TXT VARCHAR(10) = 'ABCDE'

SELECT LEN(@TXT) AS TEST_LEN

/*CHARINDEX*/

DECLARE @TXT VARCHAR(20) = 'CONSULTA BD'
SELECT CHARINDEX(' ',@TXT) AS TEST_CHARINDEX

/*PATINDEX*/

DECLARE @TXT VARCHAR(50)
SET @TXT = 'CONSULTA BD, ONDE ESTUDAMOS SOBRE OS BDS E LINGUAGEM SQL.'

SELECT PATINDEX('%BD%', @TXT) AS TEST_PATINDEX

/*REPLACE*/

DECLARE @TXT VARCHAR(50)
SET @TXT = 'APELIDO : PADAWAN'

SELECT REPLACE(@TXT, ':', '>>>') AS TEST_REPLACE

/*UPPER E LOWER*/

DECLARE @TXT VARCHAR(10)
SET @TXT = 't-SQL'

SELECT UPPER(@TXT) TEST_UPPER
SELECT LOWER(@TXT) TEST_LOWER

/*RTRIM, LTRIM, TRIM*/
DECLARE @TXT VARCHAR(20)
SET @TXT = ' T-SQL '

SELECT RTRIM(@TXT) TEST_RTRIM
SELECT LTRIM(@TXT) TEST_LTRIM
SELECT RTRIM(LTRIM(@TXT)) TEST_RTRIM_LTRIM
-- SELECT TRIM(@TXT) TEST_TRIM --> FUNCIONA SOMENTE EM VERSÕES MAIS RECENTES DO SQL SERVER SQL2017+

/*CONCATENAÇÃO DE TEXTO*/

DECLARE @TXT VARCHAR(20) = 'SQL SERVER'
			
-->>ERRO<<
SELECT @TXT + 2017 TEST_PLUS

-->>Com + e Conversão<<
SELECT @TXT + '' + CONVERT(VARCHAR(4), 2017) TEST_PLUS_CONVERT
			
-->>Com CONCAT<<
SELECT CONCAT(@TXT,'',2017) TEST_CONCAT

/*FUNÇÕES DE DATA*/

--DATEPART

SELECT
DATEPART(YEAR, GETDATE()) AS 'ANO',
DATEPART(QUARTER, GETDATE()) AS 'QUARTO DO ANO',
DATEPART(MONTH, GETDATE()) AS 'MÊS',
DATEPART(DAYOFYEAR, GETDATE()) AS 'DIA DO ANO (1 À 365)',
DATEPART(DAY, GETDATE()) AS 'DIA',
DATEPART(WEEK, GETDATE()) AS 'SEMANA',
DATEPART(WEEKDAY, GETDATE()) AS 'DIA DA SEMANA',
DATEPART(HOUR, GETDATE()) AS 'HORA',
DATEPART(MINUTE, GETDATE()) AS 'MINUTO',
DATEPART(SECOND, GETDATE()) AS 'SEGUNDO',
DATEPART(MILLISECOND, GETDATE()) AS 'MILISEGUNDO',
DATEPART(MICROSECOND, GETDATE()) AS 'MICROSEGUNDO',
DATEPART(NANOSECOND, GETDATE()) AS 'NANOSEGUNDO'

--DATEDIFF

SELECT
DATEDIFF(YEAR, '2018-01-01', GETDATE()) AS 'ANO',
DATEDIFF(MONTH, '2018-01-01', GETDATE()) AS 'MÊS',
DATEDIFF(DAY, '2018-01-01', GETDATE()) AS 'DIA',
DATEDIFF(WEEK, '2018-01-01', GETDATE()) AS 'SEMANA',
DATEDIFF(HOUR, '2018-01-01', GETDATE()) AS 'HORA',
DATEDIFF(MINUTE, '2018-01-01', GETDATE()) AS 'MINUTO'

--DATAADD

SELECT
DATEADD(YEAR,5,GETDATE()) AS 'ANO ADICIONADO',
DATEADD(YEAR,-5,GETDATE()) AS 'ANO SUBTRAIDO',
DATEADD(MONTH,5,GETDATE()) AS 'MÊS',
DATEADD(DAY,5,GETDATE()) AS 'DIA',
DATEADD(WEEK,5,GETDATE()) AS 'SEMANA',
DATEADD(HOUR,5,GETDATE()) AS 'HORA'

/*TRATAMENTO DE NULOS*/

SELECT
ISNULL (NULL, 'SQL') AS TEST_ISNULL,
NULLIF ('SQL','SQL') AS TEST_NULLIF,
NULLIF ('T-SQL','SQL) AS TEST_NULLIF2,
COALESCE (NULL, NULL, 'SQL') AS TEST_COALESCE,
COALESCE (NULL, 'T-SQL', 'SQL) AS TEST_COALESCE2


/*FUNÇÕES DE AGREGAÇÃO*/

/*COUNT*/

SELECT
COUNT(*) CONTA_TUDO,
COUNT(CATEGORIA) AS IGNORA_NULOS
FROM PRODUTO

/*SUM*/

SELECT 
SUM(QTD_ESTOQUE) SOMANDO_PRECO
FROM PRODUTO
WHERE CATEGORIA = 'INFORMATICA'

/*MAX E MIN*/

SELECT
MAX(QTD_ESTOQUE) MAIOR_ESTOQUE
FROM PRODUTO

SELECT
MIN(QTD_ESTOQUE) MENOR_ESTOQUE
FROM PRODUTO

/*AVG*/

SELECT 
AVG(QTD_ESTOQUE) MEDIA
FROM PRODUTO
WHERE CATEGORIA = 'AUTOMOTIVO'

SELECT
SUM(QTD_ESTOQUE) / COUNT(*) AS MEDIA
FROM PRODUTO
WHERE CATEGORIA = 'AUTOMOTIVO'


/*GROUP BY*/

SELECT
	CATEGORIA,
	SUM(PRECO) SOMA_PRECO
FROM PRODUTO
GROUP BY CATEGORIA

SELECT
	CATEGORIA, TIPO,
	SUM(PRECO) SOMA
FROM PRODUTO
GROUP BY CATEGORIA, TIPO
ORDER BY CATEGORIA, TIPO

/*HAVING*/

SELECT CATEGORIA,
SUM(PRECO) SOMA
FROM PRODUTO
GROUP BY CATEGORIA
HAVING SUM(PRECO) > 3500

/*VIEWS*/

--CRIANDO VIEW
CREATE VIEW uVW_DEMITIDOS
AS 
SELECT 
	NOME AS 'NOME FUNCIONARIO',
	DATAADMISSAO AS 'DATA ADMISSÃO',
	DATADEMISSAO AS 'DATA DEMISSÃO'
FROM FUNCIONARIO
WHERE DATADEMISSAO IS NOT NULL

--SELECIONANDO VIEW
SELECT * FROM uVW_DEMITIDOS

--VISUALIZANDO CODIGO DA VIEW
SP_HELPTEXT uVW_DEMITIDOS

--APAGANDO VIEW
DROP VIEW uVW_DEMITIDOS

--ALTERANDO CODIGO DA VIEW
ALTER VIEW uVW_DEMITIDOS
AS
SELECT 
	F.NOME AS 'NOME FUNCIONARIO',
	D.DESCRICAO AS 'DEPARTAMENTO',
	F.DATAADMISSAO AS 'DATA ADMISSÃO',
	F.DATADEMISSAO AS 'DATA DEMISSÃO'
FROM FUNCIONARIO AS F
	INNER JOIN DEPARTAMENTO AS D
		ON F.COD_DEPTO = D.CODIGO
WHERE DATADEMISSAO IS NOT NULL


/*STORED PROCEDURE*/

--CRIANDO PROCEDURES COM PARÂMETRO

CREATE PROCEDURE SP_INSERT_FUNCAO
(@FUNCAO VARCHAR(100))
AS
BEGIN
	INSERT INTO FUNCAO
	VALUES (@FUNCAO)
END
-- EXECUTANDO PROCEDURE

EXECUTE SP_INSERT_FUNCAO 'DIRETOR'
EXECUTE SP_INSERT_FUNCAO @FUNCAO = 'ANALISTA DE DADOS'

-- CRIANDO PROCEDURE SEM PARAMETRO

CREATE PROCEDURE uSP_FUNC_POR_FUNCAO
AS
BEGIN
	SELECT
		F.MATRICULA AS 'MATRICULA FUNCIONARIO',
		F.NOME AS 'NOME FUNCIONARIO',
		F.STATUS_FUNC AS 'STATUS FUNCIONARIO',
		FUN.DESCRICAO AS 'FUNÇÃO FUNCIONARIO'
	FROM FUNCIONARIO F
		INNER JOIN FUNCAO AS FUN
			ON (F.COD_FUNCAO = FUN.CODIGO)

END

EXECUTE uSP_FUNC_POR_FUNCAO

-- CRIANDO PROCEDURE COM PARAMETRO PARA FILTRO CONSULTA

ALTER PROCEDURE uSP_FUNC_POR_FUNCAO_2
(@FUNCAO VARCHAR(100), @STATUS varchar(10))
AS
BEGIN
	SELECT
		F.MATRICULA AS 'MATRICULA FUNCIONARIO',
		F.NOME AS 'NOME FUNCIONARIO',
		F.STATUS_FUNC AS 'STATUS FUNCIONARIO',
		FUN.DESCRICAO AS 'FUNÇÃO FUNCIONARIO'
	FROM FUNCIONARIO F
		INNER JOIN FUNCAO AS FUN
			ON (F.COD_FUNCAO = FUN.CODIGO)
			WHERE FUN.DESCRICAO = @FUNCAO and F.STATUS_FUNC = @STATUS
END

EXECUTE uSP_FUNC_POR_FUNCAO_2 @FUNCAO = 'ANALISTA JR', @STATUS = 'ATIVO'

-- DELETAR PROCEDURE

DROP PROCEDURE uSP_FUNC_POR_FUNCAO
/*STORED PROCEDURE*/

--CRIANDO PROCEDURES COM PARÂMETRO

CREATE PROCEDURE SP_INSERT_FUNCAO
(@FUNCAO VARCHAR(100))
AS
BEGIN
	INSERT INTO FUNCAO
	VALUES (@FUNCAO)
END
-- EXECUTANDO PROCEDURE

EXECUTE SP_INSERT_FUNCAO 'DIRETOR'
EXECUTE SP_INSERT_FUNCAO @FUNCAO = 'ANALISTA DE DADOS'

-- CRIANDO PROCEDURE SEM PARAMETRO

CREATE PROCEDURE uSP_FUNC_POR_FUNCAO
AS
BEGIN
	SELECT
		F.MATRICULA AS 'MATRICULA FUNCIONARIO',
		F.NOME AS 'NOME FUNCIONARIO',
		F.STATUS_FUNC AS 'STATUS FUNCIONARIO',
		FUN.DESCRICAO AS 'FUNÇÃO FUNCIONARIO'
	FROM FUNCIONARIO F
		INNER JOIN FUNCAO AS FUN
			ON (F.COD_FUNCAO = FUN.CODIGO)

END

EXECUTE uSP_FUNC_POR_FUNCAO

-- CRIANDO PROCEDURE COM PARAMETRO PARA FILTRO CONSULTA

ALTER PROCEDURE uSP_FUNC_POR_FUNCAO_2
(@FUNCAO VARCHAR(100), @STATUS varchar(10))
AS
BEGIN
	SELECT
		F.MATRICULA AS 'MATRICULA FUNCIONARIO',
		F.NOME AS 'NOME FUNCIONARIO',
		F.STATUS_FUNC AS 'STATUS FUNCIONARIO',
		FUN.DESCRICAO AS 'FUNÇÃO FUNCIONARIO'
	FROM FUNCIONARIO F
		INNER JOIN FUNCAO AS FUN
			ON (F.COD_FUNCAO = FUN.CODIGO)
			WHERE FUN.DESCRICAO = @FUNCAO and F.STATUS_FUNC = @STATUS
END

EXECUTE uSP_FUNC_POR_FUNCAO_2 @FUNCAO = 'ANALISTA JR', @STATUS = 'ATIVO'

-- DELETAR PROCEDURE

DROP PROCEDURE uSP_FUNC_POR_FUNCAO

/*TRIGGERS*/

/*EXEMPLO1*/
--CRIAR TRIGGER INSTEAD OF (PÓS UPDATE)

CREATE TRIGGER uTR_INATIVO
	ON FUNCIONARIO
	INSTEAD OF UPDATE
AS 
BEGIN
	DECLARE @STATUS_FUNC VARCHAR(50), @MATRICULA_FUNC INT

		SET @STATUS_FUNC = (SELECT STATUS_FUNC FROM inserted)
		SET @MATRICULA_FUNC = (SELECT MATRICULA FROM inserted)

	IF @STATUS_FUNC = 'INATIVO'
		UPDATE FUNCIONARIO
		SET DATADEMISSAO = CONVERT(DATE,GETDATE()),
		STATUS_FUNC = @STATUS_FUNC
		WHERE FUNCIONARIO.MATRICULA = @MATRICULA_FUNC
END

-- VISUALIZANDO INFORMAÇÕES ANTES DE EXECUTAR A TRIGGER

SELECT * FROM FUNCIONARIO
WHERE MATRICULA = 9

-- TESTANDO TRIGGER

BEGIN TRAN
	UPDATE FUNCIONARIO
	SET STATUS_FUNC = 'INATIVO'
	WHERE MATRICULA = 9
ROLLBACK

/*EXEMPLO 2*/
--TABELA AUDITORIA

CREATE TABLE [dbo].[AUDIT_FUNC](
	[MATRICULA][INT] NULL,
	[NOME][VARCHAR](255) NULL,
	[DATANASCIMENTO][DATE] NULL,
	[CPF][CHAR](11) NULL,
	[SALARIO][MONEY] NULL,
	[DATAADMISSAO][DATE] NULL,
	[DATADEMISSAO][DATE] NULL,
	[INICIOFERIAS][DATE] NULL,
	[FIMFERIAS][DATE] NULL,
	[STATUS_FUNC][VARCHAR](20) NULL,
	[CODDEPTO][INT] NULL,
	[CODSUPERVISOR][INT] NULL,
	[CODFUNCAO][INT] NULL
)

-- TRIGGER AUDITORIA FUNC
CREATE TRIGGER uTR_AUDIT_FUNC
ON FUNCIONARIO
AFTER DELETE
AS
BEGIN
	INSERT INTO AUDIT_FUNC
	SELECT * FROM deleted
END

-- TESTANTO TRIGGER AUDT

DELETE FROM FUNCIONARIO
WHERE MATRICULA = 9
ROLLBACK
-- VALIDANDO TABELAS DELETED E FUNCIONARIO

SELECT * FROM AUDIT_FUNC

SELECT * FROM FUNCIONARIO
WHERE MATRICULA = 9

/*EXEMPLO 3*/

-- EXIBIR MENSAGEM POS MODIFICAÇÃO

CREATE TABLE CAIXA(
	NUMERO INT,
	DATA DATE,
	SALDO_INICIAL MONEY,
	SALDO_FINAL MONEY)
GO

CREATE TABLE VENDAS(
	CODIGO INT,
	DATA DATE,
	VALOR MONEY)
GO


CREATE TRIGGER uTR_MSG_CAIXA
	ON CAIXA
	AFTER INSERT, UPDATE, DELETE
AS
BEGIN
	IF NOT EXISTS(SELECT*FROM inserted)
		-- DELETE
		PRINT 'OCORREU UMA REMOÇÃO NA TABELA CAIXA';
	ELSE
	BEGIN
		IF NOT EXISTS (SELECT*FROM deleted)
		-- INSERT
		PRINT 'OCORREU UMA INSERÇÃO NA TABELA CAIXA';
	ELSE
		-- UPDATE
		PRINT 'OCORREU UMA ATUALIZAÇÃO NA TABELA CAIXA';
	END
END

--TESTANDO TRIGGER

INSERT INTO CAIXA
VALUES (1,GETDATE(),100,100)
GO

SELECT * FROM CAIXA

UPDATE CAIXA
SET SALDO_INICIAL = 150
WHERE NUMERO = 1

DELETE CAIXA
WHERE NUMERO = 1

-- TRIGGER DEBITAR E CREDITAR

-- CREDITANDO

CREATE TRIGGER uTR_VENDAS_CREDITAR
	ON VENDAS
	AFTER INSERT
AS
BEGIN
	DECLARE
		@VALOR MONEY,
		@DATA DATE,
		@CODIGO INT

	SELECT @DATA = i.DATA, @VALOR = i.VALOR,
			@CODIGO = i.CODIGO FROM inserted AS i

	UPDATE CAIXA
	SET SALDO_FINAL = SALDO_FINAL + @VALOR
		WHERE DATA = @DATA
END
GO


--DEBITANDO

CREATE TRIGGER uTR_VENDAS_DEBITAR
	ON VENDAS
	AFTER DELETE
AS
BEGIN
	DECLARE
		@VALOR MONEY,
		@DATA DATE
	
	SELECT @DATA = DATA, @VALOR = VALOR FROM DELETED

	UPDATE CAIXA
	SET SALDO_FINAL = SALDO_FINAL - @VALOR
	WHERE DATA = @DATA
END
GO

-- INSERINDO NA TABELA CAIXA

INSERT INTO CAIXA
VALUES (1,GETDATE(), 100, 100)
GO

-- VERIFICANDO TABELA CAIXA
SELECT * FROM CAIXA

-- TESTANDO TRIGGER DE INSERT
INSERT INTO VENDAS
VALUES (2, GETDATE(), 50)

-- TESTANDO TRIGGER DE DELETE
DELETE FROM VENDAS
WHERE CODIGO = 2

-- TRIGGER VALIDANDO NUMERO

CREATE TRIGGER uTR_VALIDA_NUMERO
	ON  CAIXA
	AFTER INSERT
AS
IF (SELECT COUNT(*) FROM CAIXA
	INNER JOIN inserted
	ON CAIXA.NUMERO = inserted.NUMERO) > 1
BEGIN 
	Rollback TRANSACTION;
	PRINT 'ERRO'
END

-- TRIGGER VALIDANDO NUMERO2

CREATE TRIGGER uTR_VALIDA_NUMERO2
	ON CAIXA
	INSTEAD OF INSERT
AS
BEGIN
	IF EXISTS
		(SELECT * FROM CAIXA
		WHERE NUMERO = (SELECT i.NUMERO FROM inserted i))

		BEGIN
			PRINT 'ERRO - O REGISTRO JA EXISTE NA SUA TABELA'
		END
	ELSE
		BEGIN
			INSERT INTO CAIXA
			SELECT * FROM inserted
		END
END

-- TESTANDO -- TRIGGER VALIDANDO NUMERO

BEGIN TRAN
	INSERT INTO CAIXA
	VALUES (2, GETDATE(), 200,100)
GO

ROLLBACK

SELECT * FROM CAIXA

-- CRIANDO FUNÇÃO DE DATE DIFF (SCALAR)
		
CREATE FUNCTION FN_AGE
(@DTNASCIMENTO DATE)
	RETURNS INT
AS 
BEGIN
	DECLARE @AGE INT
	SELECT @AGE = DATEDIFF(YEAR,@DTNASCIMENTO,CONVERT(DATE,GETDATE()))

	RETURN @AGE
END
		
-- EXECUTANDO FUNÇÃO DATE DIFF (SCALAR)
		
SELECT 
	NOME, 
	DATANASCIMENTO, 
	DBO.FN_AGE(DATANASCIMENTO) AS IDADE
FROM FUNCIONARIO
-- OU:

SELECT dbo.FN_AGE ('2000-10-21')

-- CRIANDO FUNCTION TABLE VALUED
	
CREATE FUNCTION FN_DEMITIDO_APOS
(@DT DATE)
	RETURNS TABLE
AS
RETURN
	(
	SELECT *
	FROM uVW_DEMITIDOS AS uVW_D
	WHERE uVW_D.[DATA DEMISSÃO]>= @DT
	)

CREATE FUNCTION FN_DEMITIDOS
()
RETURNS TABLE
AS
RETURN
	SELECT * FROM uVW_DEMITIDOS AS uVW_D

SELECT * FROM FN_DEMITIDOS()
-- EXECUTANDO FUNCTION TABLE Valued

SELECT * FROM FN_DEMITIDO_APOS ('2000-10-21')

-- CRIANDO FUNCTION SCALAR para calcular nota

CREATE FUNCTION FN_RESULTADO_PROVA
(@N1 NUMERIC, @N2 NUMERIC)
	RETURNS VARCHAR(20)
AS
BEGIN
	DECLARE @RESULTADO VARCHAR(20),
			@SOMA NUMERIC
	SET @SOMA = (@N1 + @N2)/2
	IF (@SOMA >= 7)
		SELECT @RESULTADO = 'Aprovado'
	ELSE
		SELECT @RESULTADO = 'Reprovado'
RETURN @RESULTADO
END
		
-- EXECUTANDO FUNÇÃO 
		
SELECT dbo.FN_RESULTADO_PROVA(10,5)
